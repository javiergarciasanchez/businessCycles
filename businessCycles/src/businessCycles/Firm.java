/**
 * 
 * This file was automatically generated by the Repast Simphony Agent Editor.
 * Please see http://repast.sourceforge.net/ for details.
 * 
 */

/**
 *
 * Set the package name.
 *
 */
package businessCycles;

import static java.lang.Math.*;
import static repast.simphony.essentials.RepastEssentials.*;
import repast.simphony.context.Context;

/**
 * 
 * This is an agent.
 * 
 */
public class Firm {

	public static SupplyManager supplyManager;
	
	// Local state variables - change every period
	private double quantity;
	private double capital = 0.0;
	private double nextCapital = 0.0;
	
	private double perPeriodPerformance = 0.0;
	private double acumQ = 0.0;
	private double acumProfit = 0.0;
	private double profit = 0.0;
	private double maxFunding = 0.0;
	private double invest = 0.0;
	private double flexibilityCost = 0.0;
	private double unitProdCost = 0.0;
	private double learningComponent = 0.0;
	private double operatingLevarageComponent = 0.0;
	private double flexibilityCostComponent = 0.0;
	private double totalProdCost = 0.0;
	private double totalNonProdCost = 0.0;
	private double optimalMarkUp = 0.0;
	private double marginalCost = 0.0;
	private double markUp = 0.0;

	// Local firm variables - stable along firm life
	private double firstUnitCost = 0.0;
	private double operatingLeverage = 0.0;
	private double learningRate = 0.0; 
	private double expon = 0.0;
	private double born = 0.0;

	// Static Firm variables - identical for all firms
	private static double minVarCost;
	private static double minCapital;
	private static double costOfCapitalPerPeriod;

	private static double perfWeight;
	private static double minPerformance;

	private static double demElast;
	private static double supElast;

	private static double operatingLeverageMid;
	private static double operatingLeverageScale;
	private static double flexCostScale;
	private static double deprecPerPeriod;
	private static double maxExtFundPerPeriod;
	private static double invParam;

	private static long agentIDCounter;
	private long agentID = agentIDCounter++;

	public Firm(Context<Object> context) {

		context.add(this);

		born = GetTickCount();

		// A minimum first unit cost is set to 10% of mean
		firstUnitCost = max(0.1 * (Double) GetParameter("firstUnitCostMean"),
				supplyManager.firstUnitCostNormal.nextDouble());

		capital = max((Double) GetParameter("minimumCapital"), supplyManager.iniKNormal.nextDouble());

		operatingLeverage = supplyManager.operatingLeverageUniform.nextDouble();

		// Initial perfomance is set to minPerformance
		perPeriodPerformance = minPerformance;

		// Learning rate is a truncated Normal 
		// 0.5 < learning rate <= 1.0
		learningRate = min(0.99, max(supplyManager.learningRateNormal.nextDouble(), 0.51));
		expon = log(learningRate) / log(2.0);

	}

	public static void readParams() {
		// Static Firm variables - identical for all firms

		int periods = (Integer) GetParameter("periods");

		minVarCost = (Double) GetParameter("minVarCost");
		minCapital = (Double) GetParameter("minimumCapital");
		costOfCapitalPerPeriod = (Double) GetParameter("costOfCapital") / periods;

		perfWeight = (Double) GetParameter("performanceWeight");
		minPerformance = (Double) GetParameter("minimumPerformance");

		demElast = (Double) GetParameter("demandElasticity");
		supElast = (Double) GetParameter("supplyElasticity");

		double opLevMin = (Double) GetParameter("operatingLeverageMin");
		double opLevMax = (Double) GetParameter("operatingLeverageMax");
		operatingLeverageMid = (opLevMin + opLevMax) / 2.0;
		operatingLeverageScale = (opLevMax - opLevMin) / 2.0;
		
		
		flexCostScale = (Double) GetParameter("flexibilityCostScale");
		deprecPerPeriod = (Double) GetParameter("depreciation") / periods;
		maxExtFundPerPeriod = (Double) GetParameter("maxExternalFunding") / periods;
		invParam = (Double) GetParameter("investmentParam");

		agentIDCounter = 1;
	}

	public boolean checkEntry() {

		double expectedQ = Demand.getCapacityUsed() * capital;
		
		double expectedAnnualReturn = profit(expectedQ, getPrice()) *
				SupplyManager.periods / getCapital();

		return (expectedAnnualReturn >= minPerformance);

	}

	public double offer() {

		if (getBorn() < GetTickCount()) {
			capital = nextCapital;
		}

		quantity = Demand.getCapacityUsed() * capital;

		return quantity;

	}

	public double profit(double q, double p) {

		profit = p * q - totalProdCost(q) - totalNonProdCost();
		return profit;
		
	}
		
	private double totalProdCost(double quantity) {

		unitProdCost = learningComponent() * operatingLeverageComponent() * flexibilityCostComponent();
		
		totalProdCost = unitProdCost * quantity;
		
		return totalProdCost;
		
	}

	/*
	 * learning curve effect
	 */
	private double learningComponent() {
		double learningFactor = ((acumQ >= 1) ? pow(acumQ, expon) : 1);
		
		learningComponent = firstUnitCost * learningFactor + minVarCost;

		return learningComponent;
	}
	
	
	/*
	 * Adjusts cost to take into account variable and fixed costs equals 1 at full
	 * capacity
	 */
	private double operatingLeverageComponent() {
		operatingLevarageComponent = operatingLeverage / getCapacityUsed() + (1 - operatingLeverage);
		return operatingLevarageComponent;
	}

	/*
	 * Increases cost for flexible firms (low operating leverage)
	 */
	private double flexibilityCostComponent() {
		flexibilityCostComponent = 1 + flexCostScale * (operatingLeverageMid - operatingLeverage) / operatingLeverageScale;
		return flexibilityCostComponent;
	}

	private double getCapacityUsed() {
		return Demand.getCapacityUsed();
	}

	private double totalNonProdCost() {
		totalNonProdCost = (costOfCapitalPerPeriod + deprecPerPeriod) * capital;
		return totalNonProdCost;
	}

	/*
	 * 
	 * Process demand respond and returns false if firm exits the industry,
	 * otherwise returns true
	 * 
	 * @method processDemandResponse
	 * 
	 */
	public boolean processDemandResponse() {

		// Define the return value variable.
		boolean returnValue;

		// Calculates profit & Performance
		perPeriodPerformance = perfWeight * perPeriodPerformance + (1 - perfWeight) * getPerPeriodReturn();

		// if it is an exit, returns false
		double performance = perPeriodPerformance * SupplyManager.periods;
		returnValue = !(performance < minPerformance || capital < minCapital);

		acumQ += quantity;
		acumProfit += getProfit();

		return returnValue;

	}

	public void plan() {

		maxFunding = getProfit() + deprecPerPeriod * capital
				+ ((RecessionHandler.getRecesMagnitude() > 0.0) ? 0.0 : (maxExtFundPerPeriod * capital));

		invest = min(maxFunding, capital * (deprecPerPeriod + netInvestment()));

		invest = max(0.0, invest);

		nextCapital = capital * (1.0 - deprecPerPeriod) + invest;

	}

	private double netInvestment() {

		optimalMarkUp = (demElast + (1 - getMarketShare()) * supElast)
				/ (demElast + (1 - getMarketShare()) * supElast - getMarketShare());

		markUp = getPrice() / marginalCost();

		return invParam * (1 - optimalMarkUp / markUp);

	}
	
	/*
	 * Calculates marginal cost at full capacity
	 */
	private double marginalCost() {
		marginalCost = learningComponent() * flexibilityCostComponent() + costOfCapitalPerPeriod + deprecPerPeriod;
		return marginalCost;
	}

	/*
	 * Methods to probe firm state
	 */
	public double getMarketShare() {

		return quantity / supplyManager.totalQuantity;

	}

	public double getPrice() {
		return supplyManager.price;
	}

	public double getQuantity() {
		return quantity;
	}

	public double getProfit() {
		return profit;
	}

	public double getPerformance() {
		return perPeriodPerformance;
	}

	private double getPerPeriodReturn() {
		return profit / capital;
	}

	public double getReturn() {
		return getPerPeriodReturn() * SupplyManager.periods;
	}

	public double getFirstUnitCost() {
		return firstUnitCost;
	}

	public double getAcumQuantity() {
		return acumQ;
	}

	public String toString() {
		return "Firm" + this.agentID;
	}

	public long getFirmNumID() {
		return agentID;
	}

	public double getBorn() {
		return born;
	}

	public double getAge() {
		return GetTickCount() - getBorn();
	}

	public double getExpon() {
		return expon;
	}

	public double getAcumProfit() {
		return acumProfit;
	}

	public double getMedCost() {
		return (totalProdCost + totalNonProdCost) / quantity;
	}

	public double getTotalProdCost() {
		return totalProdCost;
	}

	public double getUnitProdCost() {
		return unitProdCost;
	}

	public double getTotalNonProdCost() {
		return totalNonProdCost;
	}

	public double getNonProdCostPerUnit() {
		return totalNonProdCost / quantity;
	}

	public double getOperatingLeverage() {
		return operatingLeverage;
	}
	
	public double getLearningRate() {
		return learningRate;
	}

	public double getCapital() {
		return capital;
	}

	public double getMaxFunding() {
		return maxFunding;
	}

	public double getInvest() {
		return invest;
	}

	public double getFlexibilityCost() {
		return flexibilityCost;
	}

	public static double getFlexCostScale() {
		return flexCostScale;
	}

	public double getOptimalMarkUp() {
		return optimalMarkUp;
	}

	public double getMarkUp() {
		return markUp;
	}

}
