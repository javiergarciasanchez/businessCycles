/**
 * 
 * This file was automatically generated by the Repast Simphony Agent Editor.
 * Please see http://repast.sourceforge.net/ for details.
 * 
 */

/**
 *
 * Set the package name.
 *
 */
package businessCycles;

import java.util.ArrayList;
import java.util.List;

import cern.jet.random.*;
import repast.simphony.context.Context;
import repast.simphony.engine.schedule.*;
import repast.simphony.parameter.*;
import repast.simphony.random.*;
import repast.simphony.util.collections.IndexedIterable;
import static java.lang.Math.*;
import static repast.simphony.essentials.RepastEssentials.*;

public class SupplyManager {

	private RecessionHandler recessionHandler;

	public double totalQuantity = 0;
	public double price = 0;
	public double dead = 0;
	public int bornFirms = 0;
	public double totalFirms = 1.0;
	public double totalQBeforeExit = 0;
	public double totalFBeforeExit = 1.0;

	public Normal iniKNormal = null;
	public Normal learningRateNormal = null;
	public Normal entrantsNormal = null;
	public Normal firstUnitCostNormal = null;
	public Uniform operatingLeverageUniform = null;

	public static int periods;

	private Context<Object> context;

	public SupplyManager(Context<Object> context) {

		this.context = context;
		context.add(this);

		price = (Double) GetParameter("priceOfSubstitute");

		periods = (Integer) GetParameter("periods");

		recessionHandler = new RecessionHandler();
		recessionHandler.scheduleRecessions();

		/* Create distributions for initial variables of firms */
		double iniKMean = (Double) GetParameter("iniKMean");
		double iniKStdDev = (Double) GetParameter("iniKStdDev") * iniKMean;
		iniKNormal = RandomHelper.createNormal(iniKMean, iniKStdDev);

		double entrantsMean = (Double) GetParameter("entrantsMean");
		double entrantsStdDev = (Double) GetParameter("entrantsStdDev") * entrantsMean;
		entrantsNormal = RandomHelper.createNormal(entrantsMean, entrantsStdDev);

		double firstUnitCostMean = (Double) GetParameter("firstUnitCostMean");
		double firstUnitCostStdDev = (Double) GetParameter("firstUnitCostStdDev") * firstUnitCostMean;
		firstUnitCostNormal = RandomHelper.createNormal(firstUnitCostMean, firstUnitCostStdDev);

		double learningRateMean = (Double) GetParameter("learningRateMean");
		double learningRateStdDev = (Double) GetParameter("learningRateStdDev") * learningRateMean;
		learningRateNormal = RandomHelper.createNormal(learningRateMean, learningRateStdDev);

		/*
		 * Operating Leverage is a Uniform
		 */
		double operatingLeverageMin = (Double) GetParameter("operatingLeverageMin");
		double operatingLeverageMax = (Double) GetParameter("operatingLeverageMax");
		operatingLeverageUniform = RandomHelper.createUniform(operatingLeverageMin, operatingLeverageMax);

		Firm.supplyManager = this;

	}

	@ScheduledMethod(start = 1d, interval = 1)
	public void step() {

		// Manage Entry
		int potentialEntrantsPerPeriod = (int) round(entrantsNormal.nextDouble() / periods);
		if (potentialEntrantsPerPeriod > 0)
			entry(potentialEntrantsPerPeriod);

		processOffers();

		killFirms();

		// Planning
		IndexedIterable<Object> firms = context.getObjects(Firm.class);
		for (Object f : firms)
			((Firm) f).plan();

	}

	private void entry(int potentialEntrants) {

		Firm f;
		bornFirms = 0;

		for (int j = 1; j <= potentialEntrants; j++) {

			// Destroy if not profitable
			f = new Firm(context);
			if (f.checkEntry())
				bornFirms++;
			else
				RemoveAgentFromModel(f);

		}

	}

	private void processOffers() {

		IndexedIterable<Object> firms = context.getObjects(Firm.class);

		totalFBeforeExit = firms.size();

		if (totalFBeforeExit == 0.0) {
			totalQBeforeExit = 0.0;
		} else {
			double tmpQ = 0.0;
			for (Object f : firms) {

				tmpQ += ((Firm) f).offer();

			}

			totalQBeforeExit = tmpQ;
		}

		price = Demand.price(totalQBeforeExit);

	}

	private void killFirms() {

		if (!RecessionHandler.exitOnRecession() && RecessionHandler.inRecession()) {

			totalFirms = totalFBeforeExit;
			totalQuantity = totalQBeforeExit;
			return;

		} else {

			IndexedIterable<Object> firms = context.getObjects(Firm.class);

			List<Firm> toKill = new ArrayList<Firm>(firms.size());

			for (Object f : context.getObjects(Firm.class)) {

				// Process Demand Response
				if (!((Firm) f).processDemandResponse()) {
					toKill.add((Firm) f);
				}

			}

			dead = toKill.size();
			for (Firm f : toKill) {
				RemoveAgentFromModel(f);
			}

			firms = context.getObjects(Firm.class);

			totalFirms = firms.size();

			if (totalFirms == 0.0) {
				totalQuantity = 0.0;
			} else {
				double tmpQ = 0.0;
				for (Object f : firms) {
					tmpQ += ((Firm) f).getQuantity();
				}
				totalQuantity = tmpQ;
			}

		}

	}

	public String toString() {

		return "SupplyManager";

	}

	public double getCapacityUsed() {
		return Demand.getCapacityUsed();
	}

	@Parameter(displayName = "Total Quantity", usageName = "totalQuantity")
	public double getTotalQuantity() {
		return totalQuantity;
	}

	@Parameter(displayName = "Price", usageName = "price")
	public double getPrice() {
		return price;
	}

	@Parameter(displayName = "Dead", usageName = "dead")
	public double getDead() {
		return dead;
	}

	@Parameter(displayName = "Born Firms", usageName = "bornFirms")
	public int getBornFirms() {
		return bornFirms;
	}

	@Parameter(displayName = "Total Firms", usageName = "totalFirms")
	public double getTotalFirms() {
		return totalFirms;
	}

	@Parameter(displayName = "Total Q Before Exit", usageName = "totalQBeforeExit")
	public double getTotalQBeforeExit() {
		return totalQBeforeExit;
	}

	@Parameter(displayName = "Total F Before Exit", usageName = "totalFBeforeExit")
	public double getTotalFBeforeExit() {
		return totalFBeforeExit;
	}

}
